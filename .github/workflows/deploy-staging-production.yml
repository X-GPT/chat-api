name: Deploy to Staging & Production (Image ‚Üí ECR ‚Üí EC2)

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: us-west-2
  ECR_REPO: ${{ github.event.repository.name }}
  EC2_HOST: ec2-52-35-68-202.us-west-2.compute.amazonaws.com
  EC2_USER: deploy
  EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}

  # Staging Environment
  STAGING_HOST_PORT: 8094
  STAGING_CONTAINER_PORT: 3000

  # Production Environment
  PROD_HOST_PORT: 8095
  PROD_CONTAINER_PORT: 3000

  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Compose files
  MYMEMO_COMPOSE_DIR: /etc/mymemo/chat-api
  STAGING_COMPOSE_FILE: /etc/mymemo/chat-api/compose.staging.yaml
  PROD_COMPOSE_FILE: /etc/mymemo/chat-api/compose.production.yaml

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.ref }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run linting
        run: bun run lint

      - name: Run tests
        run: bun test

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: test
    outputs:
      registry: ${{ steps.ecr-login.outputs.registry }}
      api_image_sha_tag: ${{ steps.meta.outputs.api_image_sha_tag }}
      api_image_latest_tag: ${{ steps.meta.outputs.api_image_latest_tag }}
      worker_image_sha_tag: ${{ steps.meta.outputs.worker_image_sha_tag }}
      worker_image_latest_tag: ${{ steps.meta.outputs.worker_image_latest_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute tags
        id: meta
        run: |
          REG="${{ steps.ecr-login.outputs.registry }}"
          REPO="${{ env.ECR_REPO }}"

          # API image tags
          echo "api_image_sha_tag=${REG}/${REPO}:staging-${GITHUB_SHA:0:7}" >> "$GITHUB_OUTPUT"
          echo "api_image_latest_tag=${REG}/${REPO}:staging-latest" >> "$GITHUB_OUTPUT"

          # Worker image tags
          echo "worker_image_sha_tag=${REG}/${REPO}-worker:staging-${GITHUB_SHA:0:7}" >> "$GITHUB_OUTPUT"
          echo "worker_image_latest_tag=${REG}/${REPO}-worker:staging-latest" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR repositories exist
        run: |
          set -euo pipefail
          REPO="${{ env.ECR_REPO }}"
          WORKER_REPO="${REPO}-worker"
          REGION="${{ env.AWS_REGION }}"

          # Create API repository
          if ! aws ecr describe-repositories --repository-names "$REPO" --region "$REGION" >/dev/null 2>&1; then
            echo "Creating ECR repository: $REPO in $REGION"
            aws ecr create-repository \
              --repository-name "$REPO" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 \
              --region "$REGION" >/dev/null
          fi

          # Create Worker repository
          if ! aws ecr describe-repositories --repository-names "$WORKER_REPO" --region "$REGION" >/dev/null 2>&1; then
            echo "Creating ECR repository: $WORKER_REPO in $REGION"
            aws ecr create-repository \
              --repository-name "$WORKER_REPO" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256 \
              --region "$REGION" >/dev/null
          fi

      - name: Build & Push API image (with cache)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.api_image_sha_tag }}
            ${{ steps.meta.outputs.api_image_latest_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & Push Worker image (with cache)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.worker
          push: true
          tags: |
            ${{ steps.meta.outputs.worker_image_sha_tag }}
            ${{ steps.meta.outputs.worker_image_latest_tag }}
          cache-from: type=gha,scope=worker
          cache-to: type=gha,mode=max,scope=worker

  deploy-to-staging:
    name: Deploy to Staging EC2
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-and-push
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Copy compose file to EC2
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          source: "compose.staging.yaml"
          target: "/tmp/chat-api/"

      - name: Deploy on Staging EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          script: |
            set -euxo pipefail

            # Settings from workflow
            AWS_REGION="${{ env.AWS_REGION }}"
            REPO_NAME="${{ env.ECR_REPO }}"
            HOST_PORT="${{ env.STAGING_HOST_PORT }}"
            CONTAINER_PORT="${{ env.STAGING_CONTAINER_PORT }}"
            API_IMAGE="${{ needs.build-and-push.outputs.api_image_sha_tag }}"
            WORKER_IMAGE="${{ needs.build-and-push.outputs.worker_image_sha_tag }}"

            echo "üöÄ Deploying to staging: API=$API_IMAGE, Worker=$WORKER_IMAGE"

            # Login to ECR
            REGISTRY="${API_IMAGE%%/*}"
            aws ecr get-login-password --region "$AWS_REGION" \
              | sudo docker login --username AWS --password-stdin "$REGISTRY"

            # Pull the new images
            sudo docker pull "$API_IMAGE"
            sudo docker pull "$WORKER_IMAGE"

            # Install/update compose file in shared config location
            sudo -n mkdir -p /etc/mymemo/chat-api
            sudo -n mv /tmp/chat-api/compose.staging.yaml "${{ env.MYMEMO_COMPOSE_DIR }}/compose.staging.yaml"
            sudo -n chmod 644 "${{ env.MYMEMO_COMPOSE_DIR }}/compose.staging.yaml"

            # Export environment variables for compose
            export REPO_NAME
            export API_IMAGE
            export WORKER_IMAGE
            export HOST_PORT
            export CONTAINER_PORT

            # Stop and remove old containers
            sudo -n API_IMAGE="$API_IMAGE" WORKER_IMAGE="$WORKER_IMAGE" HOST_PORT="$HOST_PORT" CONTAINER_PORT="$CONTAINER_PORT" REPO_NAME="$REPO_NAME" \
              docker-compose -f "${{ env.STAGING_COMPOSE_FILE }}" -p chat-api-staging down || true

            # Start new containers
            sudo -n API_IMAGE="$API_IMAGE" WORKER_IMAGE="$WORKER_IMAGE" HOST_PORT="$HOST_PORT" CONTAINER_PORT="$CONTAINER_PORT" REPO_NAME="$REPO_NAME" \
              docker-compose -f "${{ env.STAGING_COMPOSE_FILE }}" -p chat-api-staging up -d

            echo "‚úÖ Staging deployment completed - API on port $HOST_PORT, Worker running"

            # Show container status
            echo "üìã Staging Container Status:"
            sudo docker ps --filter name="${REPO_NAME}-staging" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Clean up old images (keep some for rollback)
            sudo docker image prune -f --filter "until=24h"

  staging-smoke-test:
    name: Staging Smoke Test
    runs-on: ubuntu-latest
    needs: [deploy-to-staging]
    steps:
      - name: Staging Health Check
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          script: |
            set -euxo pipefail

            REPO_NAME="${{ env.ECR_REPO }}"
            API_CONTAINER_NAME="${REPO_NAME}-staging-api"
            WORKER_CONTAINER_NAME="${REPO_NAME}-staging-worker"
            HOST_PORT="${{ env.STAGING_HOST_PORT }}"

            echo "üîç Running staging health checks..."

            # Health check - test basic API endpoint
            for i in {1..30}; do
              if curl -fsS "http://127.0.0.1:${HOST_PORT}/" | grep -q "Hello Hono!"; then
                echo "üöÄ Staging API service healthy ‚úÖ - Root endpoint responding"

                # Additional check for API endpoint
                if curl -fsS "http://127.0.0.1:${HOST_PORT}/v1/chat" -X POST \
                  -H "Content-Type: application/json" \
                  -d '{"messages":[]}' > /dev/null 2>&1; then
                  echo "üöÄ Staging API endpoints healthy ‚úÖ"
                else
                  echo "‚ö†Ô∏è Staging API endpoints responding but may have issues"
                fi

                # Check worker container is running
                if sudo docker ps --format '{{.Names}}' | grep -q "^$WORKER_CONTAINER_NAME$"; then
                  echo "üöÄ Staging Worker container running ‚úÖ"
                else
                  echo "‚ö†Ô∏è Staging Worker container not running"
                  sudo docker logs "$WORKER_CONTAINER_NAME" || true
                fi

                exit 0
              fi
              echo "Waiting for staging health... ($i/30)"; sleep 2
            done

            echo "‚ùå Staging service failed health check, dumping logs"
            echo "API logs:"
            sudo docker logs "$API_CONTAINER_NAME" || true
            sudo docker inspect "$API_CONTAINER_NAME" --format 'Exit={{.State.ExitCode}} OOM={{.State.OOMKilled}} Error={{.State.Error}}' || true
            echo "Worker logs:"
            sudo docker logs "$WORKER_CONTAINER_NAME" || true
            exit 1

  deploy-to-production:
    name: Deploy to Production EC2
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [build-and-push, staging-smoke-test]
    # Only deploy to production after staging smoke test succeeds
    if: always() && needs.staging-smoke-test.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.3.1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set staging image for production
        id: set-image
        run: |
          # Use image from staging deployment
          API_STAGING_IMAGE="${{ needs.build-and-push.outputs.api_image_sha_tag }}"
          WORKER_STAGING_IMAGE="${{ needs.build-and-push.outputs.worker_image_sha_tag }}"
          echo "üì¶ Using api staging image for production: ${API_STAGING_IMAGE}"
          echo "api_staging_image=${API_STAGING_IMAGE}" >> $GITHUB_OUTPUT
          echo "üì¶ Using worker staging image for production: ${WORKER_STAGING_IMAGE}"
          echo "worker_staging_image=${WORKER_STAGING_IMAGE}" >> $GITHUB_OUTPUT

      - name: Copy compose file to EC2
        uses: appleboy/scp-action@v1
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          source: "compose.production.yaml"
          target: "/tmp/chat-api/"

      - name: Deploy on Production EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          script: |
            set -euxo pipefail

            # Settings from workflow
            AWS_REGION="${{ env.AWS_REGION }}"
            REPO_NAME="${{ env.ECR_REPO }}"
            HOST_PORT="${{ env.PROD_HOST_PORT }}"
            CONTAINER_PORT="${{ env.PROD_CONTAINER_PORT }}"
            API_IMAGE="${{ steps.set-image.outputs.api_staging_image }}"
            WORKER_IMAGE="${{ steps.set-image.outputs.worker_staging_image }}"

            echo "üöÄ Deploying staging images to production: API=$API_IMAGE, Worker=$WORKER_IMAGE"

            # Login to ECR
            REGISTRY="${API_IMAGE%%/*}"
            aws ecr get-login-password --region "$AWS_REGION" \
              | sudo docker login --username AWS --password-stdin "$REGISTRY"

            # Pull the staging images for production use
            sudo docker pull "$API_IMAGE"
            sudo docker pull "$WORKER_IMAGE"

            # Install/update compose file in shared config location
            sudo -n mkdir -p /etc/mymemo/chat-api
            sudo -n mv /tmp/chat-api/compose.production.yaml "${{ env.MYMEMO_COMPOSE_DIR }}/compose.production.yaml"
            sudo -n chmod 644 "${{ env.MYMEMO_COMPOSE_DIR }}/compose.production.yaml"

            # Export environment variables for compose
            export REPO_NAME
            export API_IMAGE
            export WORKER_IMAGE
            export HOST_PORT
            export CONTAINER_PORT

            # Stop and remove old containers
            sudo -n API_IMAGE="$API_IMAGE" WORKER_IMAGE="$WORKER_IMAGE" HOST_PORT="$HOST_PORT" CONTAINER_PORT="$CONTAINER_PORT" REPO_NAME="$REPO_NAME" \
              docker-compose -f "${{ env.PROD_COMPOSE_FILE }}" -p chat-api-production down || true

            # Start new containers
            sudo -n API_IMAGE="$API_IMAGE" WORKER_IMAGE="$WORKER_IMAGE" HOST_PORT="$HOST_PORT" CONTAINER_PORT="$CONTAINER_PORT" REPO_NAME="$REPO_NAME" \
              docker-compose -f "${{ env.PROD_COMPOSE_FILE }}" -p chat-api-production up -d

            echo "‚úÖ Production deployment completed - API on port $HOST_PORT, Worker running"

            # Show container status
            echo "üìã Production Container Status:"
            sudo docker ps --filter name="${REPO_NAME}-production" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Clean up old images (keep more for production rollback)
            sudo docker image prune -f --filter "until=48h"

  production-smoke-test:
    name: Production Smoke Test
    runs-on: ubuntu-latest
    needs: [deploy-to-production]
    steps:
      - name: Production Health Check
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_SSH_KEY }}
          port: 22
          script: |
            set -euxo pipefail

            REPO_NAME="${{ env.ECR_REPO }}"
            API_CONTAINER_NAME="${REPO_NAME}-production-api"
            WORKER_CONTAINER_NAME="${REPO_NAME}-production-worker"
            HOST_PORT="${{ env.PROD_HOST_PORT }}"

            echo "üîç Running production health checks..."

            # Health check - test basic API endpoint
            for i in {1..30}; do
              if curl -fsS "http://127.0.0.1:${HOST_PORT}/" | grep -q "Hello Hono!"; then
                echo "üöÄ Production API service healthy ‚úÖ - Root endpoint responding"

                # Additional check for API endpoint
                if curl -fsS "http://127.0.0.1:${HOST_PORT}/v1/chat" -X POST \
                  -H "Content-Type: application/json" \
                  -d '{"messages":[]}' > /dev/null 2>&1; then
                  echo "üöÄ Production API endpoints healthy ‚úÖ"
                else
                  echo "‚ö†Ô∏è Production API endpoints responding but may have issues"
                fi

                # Check worker container is running
                if sudo docker ps --format '{{.Names}}' | grep -q "^$WORKER_CONTAINER_NAME$"; then
                  echo "üöÄ Production Worker container running ‚úÖ"
                  echo "üéâ Production deployment completed successfully!"
                else
                  echo "‚ö†Ô∏è Production Worker container not running"
                  sudo docker logs "$WORKER_CONTAINER_NAME" || true
                fi

                exit 0
              fi
              echo "Waiting for production health... ($i/30)"; sleep 2
            done

            echo "‚ùå Production service failed health check, dumping logs"
            echo "API logs:"
            sudo docker logs "$API_CONTAINER_NAME" || true
            sudo docker inspect "$API_CONTAINER_NAME" --format 'Exit={{.State.ExitCode}} OOM={{.State.OOMKilled}} Error={{.State.Error}}' || true
            echo "Worker logs:"
            sudo docker logs "$WORKER_CONTAINER_NAME" || true
            exit 1

